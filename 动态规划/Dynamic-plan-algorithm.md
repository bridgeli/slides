# 如何巧妙解决“双十一”购物时的凑单问题？

分享者：[BridgeLi, https://www.bridgeli.cn](https://www.bridgeli.cn)

## 问题提出

阿里京东的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。假设你女朋友（如果你有的话）的购物车中有 n 个（n > 100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），这样就可以极大限度地“薅羊毛”。我们都是程序员，所以作为程序员的你，能不能编个代码来帮她搞定呢？

## 目录

-   问题提出
-   0-1 背包问题
-   回溯算法解决方案
-   回溯算法的问题
-   动态规划算法解决方案
-   两个算法的时间复杂度分析
-   动态规划算法的优化
-   0-1 背包问题的升级版
-   凑单问题解决

## 0-1 背包问题

在解决帮你女朋友购物的问题之前，我们先看一个：0-1 背包问题。对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

### 回溯算法解决方案

回溯的解决方法，其实可以理解成：穷举搜索所有可能的装法，然后找出满足条件的最大值

### 算法思想

其实我们可以构造一个递归树，递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2，递归树图如下：

### 图解回溯算法

![图解回溯算法](../assets/images/Dynamic-plan-algorithm/huisu.jpg)

### 代码示例

```java
// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。
private int maxW = Integer.MIN_VALUE; // 结果放到maxW中
private int[] weight = {2, 2, 4, 6, 3};  // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
public void f( int i, int cw) { // 调用f(0, 0)
    if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
        if (cw > maxW) {
            maxW = cw;
        }
        return;
    }
    f(i + 1, cw); // 选择不装第i个物品
    if (cw + weight[i] <= w) {
        f(i + 1, cw + weight[i]); // 选择装第i个物品
    }
}
```



### 回溯算法存在的问题

从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。我们可以借助“备忘录”的解决方式，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。

### 优化之后的代码示例

```java
private int maxW = Integer.MIN_VALUE; // 结果放到maxW中
private int[] weight = {2, 2, 4, 6, 3};  // 物品重量
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量
private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值false
public void f( int i, int cw) { // 调用f(0, 0)
    if (cw == w || i == n) { // cw==w表示装满了，i==n表示物品都考察完了
        if (cw > maxW) {
            maxW = cw;
        }
        return;
    }
    if (mem[i][cw]) {
        return; // 重复状态
    }
    mem[i][cw] = true; // 记录(i, cw)这个状态
    f(i + 1, cw); // 选择不装第i个物品
    if (cw + weight[i] <= w) {
        f(i + 1, cw + weight[i]); // 选择装第i个物品
    }
}
```

### 有没有其他的思路

其实仔细想想这个和我们高中学习的动态规划是不是很类似？还记得我们高中学过的动态规划吗？

## 动态规划解决思路

我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。

我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，我们就成功避免了每层状态个数的指数级增长。

### 动态规划解决思路（续）

我们用一个二维数组 states\[n][w+1]，来记录每层可以达到的不同状态。第 0 个物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states\[0][0]=true 和 states\[0][2]=true 来表示这两种状态。第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states\[1][0]=true，states\[1][2]=true，states\[1][4]=true 来表示这三种状态。以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。整个计算的过程如下画，图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w 的值，就是背包中物品总重量的最大值

### 图解动态规划算法

![图解回溯算法](../assets/images/Dynamic-plan-algorithm/guihua.jpg)

### 图解动态规划算法（续）

![图解回溯算法](../assets/images/Dynamic-plan-algorithm/guihuaxu.jpg)

### 动态规划算法代码示例

```java
// weight:物品重量，n:物品个数，w:背包可承载重量
public int knapsack(int[] weight, int n, int w) {
    boolean[][] states = new boolean[n][w + 1]; // 默认值false
    states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化
    if (weight[0] <= w) {
        states[0][weight[0]] = true;
    }
    for (int i = 1; i < n; ++i) { // 动态规划状态转移
        for (int j = 0; j <= w; ++j) { // 不把第i个物品放入背包
            if (states[i - 1][j]) {
                states[i][j] = states[i - 1][j];
            }
        }
        for (int j = 0; j <= w - weight[i]; ++j) { // 把第i个物品放入背包
            if (states[i - 1][j]) {
                states[i][j + weight[i]] = true;
            }
        }
    }
    for (int i = w; i >= 0; --i) { // 输出结果
        if (states[n - 1][i]) {
            return i;
        }
    }
    return 0;
}
```

### 上面的代码有疑问吗？

输出结果的时候为什么从大到小？

## 两个算法的时间复杂度分析

#### 回溯算法时间复杂度

前面我们讲到，用回溯算法解决这个问题的时间复杂度 O(2^n)，是指数级的。那动态规划解决方案的时间复杂度是多少呢？我来分析一下。

#### 动态规划算法复杂度

这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。

## 回忆：还记得我第一节分享过的时间复杂度分析吗？

#### 回溯算法和动态规划算法的比较

从理论上讲，指数级的时间复杂度肯定要比 O(nw) 高很多，但是为了让你有更加深刻的感受，我来举一个例子给你比较一下。我们假设有 10000 个物品，重量分布在 1 到 15000 之间，背包可以承载的总重量是 30000。如果我们用回溯算法解决，用具体的数值表示出时间复杂度，就是 2^10000，这是一个相当大的一个数字。如果我们用动态规划解决，用具体的数值表示出时间复杂度，就是 1000030000。虽然看起来也很大，但是和 2^10000 比起来，要小太多了。

### 动态规划算法存在的问题

尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。你可能要问了，有什么办法可以降低空间消耗吗？

### 动态规划算法的优化思路

实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。

### 动态规划算法优化

```java
public static int knapsack2(int[] items, int n, int w) {
    boolean[] states = new boolean[w + 1]; // 默认值false
    states[0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
    if (items[0] <= w) {
        states[items[0]] = true;
    }
    for (int i = 1; i < n; ++i) { // 动态规划
        for (int j = w - items[i]; j >= 0; --j) {//把第i个物品放入背包
            if (states[j]) {
                states[j + items[i]] = true;
            }
        }
    }
    for (int i = w; i >= 0; --i) { // 输出结果
        if (states[i]) {
            return i;
        }
    }
    return 0;
}
```

## 0-1 背包问题的升级版

我们刚刚讲的背包问题，只涉及背包重量和物品重量。我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？

### 回溯算法递归树

因为思想我们刚看过了（还记得吗？）所以我们直接看递归树好了

### 递归树如下：

![回溯算法升级](../assets/images/Dynamic-plan-algorithm/huisu_optimize.jpg)

### 回溯算法代码示例

```java
private int maxV = Integer.MIN_VALUE; // 结果放到maxV中
private int[] items = {2, 2, 4, 6, 3};  // 物品的重量
private int[] value = {3, 4, 8, 9, 6}; // 物品的价值
private int n = 5; // 物品个数
private int w = 9; // 背包承受的最大重量

public void f(int i, int cw, int cv) { // 调用f(0, 0, 0)
    if (cw == w || i == n) { // cw==w 表示装满了，i==n 表示物品都考察完了
        if (cv > maxV) {
            maxV = cv;
        }
        return;
    }
    f(i + 1, cw, cv); // 选择不装第i个物品
    if (cw + weight[i] <= w) {
        f(i + 1, cw + weight[i], cv + value[i]); // 选择装第i个物品
    }
}
```



## 回溯算法存在的问题

我们发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。

也就是说，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。

思路说完了，但是代码如何实现呢？如果用回溯算法，这个问题就没法再用“备忘录”解决了。所以，我们就需要换一种思路，看看动态规划是不是更容易解决这个问题？

### 如何解决

我们还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。

我们用一个二维数组 states\[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。

### 代码示例

```java
public static int knapsack3(int[] weight, int[] value, int n, int w) {
    int[][] states = new int[n][w+1];
    for (int i = 0; i < n; ++i) { // 初始化states
        for (int j = 0; j < w+1; ++j) {
            states[i][j] = -1;
        }
    }
    states[0][0] = 0;
    if (weight[0] <= w) {
        states[0][weight[0]] = value[0];
    }
    for (int i = 1; i < n; ++i) { // 动态规划，状态转移
        for (int j = 0; j <= w; ++j) { // 不选择第i个物品
            if (states[i-1][j] >= 0) {
                states[i][j] = states[i-1][j];
            }
        }
        for (int j = 0; j <= w-weight[i]; ++j) { // 选择第i个物品
            if (states[i-1][j] >= 0) {
                int v = states[i-1][j] + value[i];
                if (v > states[i][j+weight[i]]) {
                    states[i][j+weight[i]] = v;
                }
            }
        }
    }
    // 找出最大值
    int maxvalue = -1;
    for (int j = 0; j <= w; ++j) {
        if (states[n - 1][j] > maxvalue) {
            maxvalue = states[n - 1][j];
        }
    }
    return maxvalue;
}
```

## 凑单问题解决

### 回溯算法

对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 200 并且最接近 200 的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。当 n 很大的时候，可能“双十一”已经结束了，你的代码还没有运行出结果（技术不熟练，后果很严重的）

### 动态规划算法

实际上，它跟第一个例子中讲的 0-1 背包问题很像，只不过是把“重量”换成了“价格”而已。购物车中有 n 个商品。我们针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。我们还是用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。不过，这里的 x 值是多少呢？就要根据实际情况判断了

### 代码示例

```java
// items商品价格，n商品个数, w表示满减条件，比如200
public static void double11advance(int[] items, int n, int w) {
    boolean[][] states = new boolean[n][3 * w + 1];//超过3倍就没有薅羊毛的价值了
    states[0][0] = true;  // 第一行的数据要特殊处理
    if (items[0] <= 3 * w) {
        states[0][items[0]] = true;
    }
    for (int i = 1; i < n; ++i) { // 动态规划
        for (int j = 0; j <= 3 * w; ++j) {// 不购买第i个商品
            if (states[i - 1][j]) {
                states[i][j] = states[i - 1][j];
            }
        }
        for (int j = 0; j <= 3 * w - items[i]; ++j) {//购买第i个商品
            if (states[i - 1][j]) {
                states[i][j + items[i]] = true;
            }
        }
    }

    int j;
    for (j = w; j < 3 * w + 1; ++j) {
        if (states[n - 1][j] == true) {
            break; // 输出结果大于等于w的最小值
        }
    }
    if (j == 3 * w + 1) {
        return; // 没有可行解
    }
    for (int i = n - 1; i >= 1; --i) { // i表示二维数组中的行，j表示列
        if (j - items[i] >= 0 && states[i - 1][j - items[i]]) {
            System.out.print(items[i] + " "); // 购买这个商品
            j = j - items[i];
        } // else 没有购买这个商品，j不变。
    }
    if (j != 0) {
        System.out.print(items[0]);
    }
}
```

### 代码解析

代码的前半部分跟 0-1 背包问题没有什么不同，我们着重看后半部分，看它是如何打印出选择购买哪些商品的。

状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states\[i-1][j] 或者 states\[i-1][j-value[i]] 是否是 true。

如果 states\[i-1][j] 可达，就说明我们没有选择购买第 i 个商品，如果 states\[i-1][j-value[i]] 可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。

## Thanks

参考资料：[BridgeLi, https://www.bridgeli.cn](https://www.bridgeli.cn)

《极客时间，数据结构和算法之美》